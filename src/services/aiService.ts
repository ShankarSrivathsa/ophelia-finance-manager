interface AIServiceConfig {
  provider: 'gemini' | 'openai' | 'anthropic';
  apiKey: string;
}

interface FinancialData {
  monthlyIncome: number;
  monthlyExpenses: number;
  expenses: Array<{
    amount: number;
    category: string;
    date: string;
    description: string;
  }>;
  income: Array<{
    amount: number;
    category: string;
    date: string;
    description: string;
  }>;
  budgets: Array<{
    category: string;
    amount: number;
    spent: number;
  }>;
  savingsGoals: Array<{
    name: string;
    targetAmount: number;
    currentAmount: number;
    targetDate: string;
  }>;
  userProfile?: {
    persona: string;
  };
}

interface AIAdviceResponse {
  advice: string;
  recommendations: Array<{
    category: string;
    action: string;
    impact: string;
    priority: 'high' | 'medium' | 'low';
  }>;
  insights: Array<{
    type: 'warning' | 'opportunity' | 'achievement';
    message: string;
    data?: any;
  }>;
}

interface BudgetOptimizationResponse {
  adjustments: Array<{
    category: string;
    currentAmount: number;
    suggestedAmount: number;
    reasoning: string;
    confidence: number;
  }>;
  totalSavings: number;
  impactAnalysis: string;
}

interface ReportResponse {
  reportTitle: string;
  summary: string;
  sections: Array<{
    title: string;
    content: string;
    data?: any;
  }>;
  keyMetrics: Array<{
    name: string;
    value: string;
    trend: 'up' | 'down' | 'stable';
    significance: string;
  }>;
  recommendations: string[];
}

class AIService {
  private config: AIServiceConfig | null = null;

  constructor() {
    this.initializeConfig();
  }

  private initializeConfig() {
    // Check environment variables for API keys
    const geminiKey = import.meta.env.VITE_GEMINI_API_KEY;
    const openaiKey = import.meta.env.VITE_OPENAI_API_KEY;
    const anthropicKey = import.meta.env.VITE_ANTHROPIC_API_KEY;

    if (geminiKey) {
      this.config = { provider: 'gemini', apiKey: geminiKey };
      console.log('✅ Gemini AI configured from environment');
    } else if (openaiKey) {
      this.config = { provider: 'openai', apiKey: openaiKey };
      console.log('✅ OpenAI configured');
    } else if (anthropicKey) {
      this.config = { provider: 'anthropic', apiKey: anthropicKey };
      console.log('✅ Anthropic configured');
    } else {
      console.warn('⚠️ No AI provider configured');
    }
  }

  private async callGeminiAPI(prompt: string): Promise<string> {
    if (!this.config || this.config.provider !== 'gemini') {
      throw new Error('Gemini API not configured');
    }

    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.0-pro:generateContent?key=${this.config.apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
          }
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Gemini API error: ${response.status} - ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!generatedText) {
        throw new Error('No content generated by Gemini');
      }
      
      return generatedText;
    } catch (error) {
      console.error('Gemini API call failed:', error);
      throw error;
    }
  }

  private async callOpenAIAPI(prompt: string): Promise<string> {
    if (!this.config || this.config.provider !== 'openai') {
      throw new Error('OpenAI API not configured');
    }

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.config.apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: 'You are a professional financial advisor providing personalized advice based on user data.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: 2000,
        temperature: 0.7
      })
    });

    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.status}`);
    }

    const data = await response.json();
    return data.choices[0]?.message?.content || 'No response generated';
  }

  private async callAnthropicAPI(prompt: string): Promise<string> {
    if (!this.config || this.config.provider !== 'anthropic') {
      throw new Error('Anthropic API not configured');
    }

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.config.apiKey}`,
        'Content-Type': 'application/json',
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-sonnet-20240229',
        max_tokens: 2000,
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ]
      })
    });

    if (!response.ok) {
      throw new Error(`Anthropic API error: ${response.status}`);
    }

    const data = await response.json();
    return data.content[0]?.text || 'No response generated';
  }

  private async callAI(prompt: string): Promise<string> {
    if (!this.config) {
      throw new Error('No AI provider configured. Please add an API key for Gemini, OpenAI, or Anthropic.');
    }

    try {
      switch (this.config.provider) {
        case 'gemini':
          return await this.callGeminiAPI(prompt);
        case 'openai':
          return await this.callOpenAIAPI(prompt);
        case 'anthropic':
          return await this.callAnthropicAPI(prompt);
        default:
          throw new Error('Unknown AI provider');
      }
    } catch (error) {
      console.error(`${this.config.provider} API call failed:`, error);
      throw error;
    }
  }

  async getFinancialAdvice(financialData: FinancialData, requestType: string): Promise<AIAdviceResponse> {
    const prompt = this.buildAdvicePrompt(financialData, requestType);
    
    try {
      const response = await this.callAI(prompt);
      return this.parseAdviceResponse(response);
    } catch (error) {
      console.error('AI advice generation failed:', error);
      return this.getFallbackAdvice(financialData);
    }
  }

  async optimizeBudget(financialData: FinancialData): Promise<BudgetOptimizationResponse> {
    const prompt = this.buildBudgetOptimizationPrompt(financialData);
    
    try {
      const response = await this.callAI(prompt);
      return this.parseBudgetOptimizationResponse(response, financialData);
    } catch (error) {
      console.error('Budget optimization failed:', error);
      return this.getFallbackBudgetOptimization(financialData);
    }
  }

  async generateReport(financialData: FinancialData, reportType: string, dateRange: { startDate: string; endDate: string }): Promise<ReportResponse> {
    const prompt = this.buildReportPrompt(financialData, reportType, dateRange);
    
    try {
      const response = await this.callAI(prompt);
      return this.parseReportResponse(response, financialData);
    } catch (error) {
      console.error('Report generation failed:', error);
      return this.getFallbackReport(financialData, reportType);
    }
  }

  private buildAdvicePrompt(data: FinancialData, requestType: string): string {
    const netIncome = data.monthlyIncome - data.monthlyExpenses;
    const savingsRate = data.monthlyIncome > 0 ? ((netIncome / data.monthlyIncome) * 100) : 0;
    
    return `
As a professional financial advisor, analyze this user's financial situation and provide personalized advice.

USER PROFILE:
- Persona: ${data.userProfile?.persona || 'general'}
- Monthly Income: $${data.monthlyIncome.toFixed(2)}
- Monthly Expenses: $${data.monthlyExpenses.toFixed(2)}
- Net Income: $${netIncome.toFixed(2)}
- Savings Rate: ${savingsRate.toFixed(1)}%

RECENT EXPENSES (last 10):
${data.expenses.slice(0, 10).map(exp => `- ${exp.category}: $${exp.amount} (${exp.description})`).join('\n')}

BUDGETS:
${data.budgets.map(budget => `- ${budget.category}: $${budget.spent}/$${budget.amount} (${((budget.spent/budget.amount)*100).toFixed(1)}% used)`).join('\n')}

SAVINGS GOALS:
${data.savingsGoals.map(goal => `- ${goal.name}: $${goal.currentAmount}/$${goal.targetAmount} (${((goal.currentAmount/goal.targetAmount)*100).toFixed(1)}% complete, target: ${goal.targetDate})`).join('\n')}

REQUEST TYPE: ${requestType}

Please provide a response in this exact JSON format:
{
  "advice": "Main financial advice paragraph (2-3 sentences)",
  "recommendations": [
    {
      "category": "Category name",
      "action": "Specific action to take",
      "impact": "Expected impact/benefit",
      "priority": "high|medium|low"
    }
  ],
  "insights": [
    {
      "type": "warning|opportunity|achievement",
      "message": "Insight message",
      "data": {}
    }
  ]
}

Focus on actionable, specific advice based on their persona and current financial situation.
`;
  }

  private buildBudgetOptimizationPrompt(data: FinancialData): string {
    return `
As a financial optimization expert, analyze this budget and suggest improvements.

CURRENT BUDGET PERFORMANCE:
${data.budgets.map(budget => {
  const percentage = (budget.spent / budget.amount) * 100;
  const status = percentage > 100 ? 'OVER' : percentage > 80 ? 'HIGH' : 'OK';
  return `- ${budget.category}: $${budget.spent}/$${budget.amount} (${percentage.toFixed(1)}% - ${status})`;
}).join('\n')}

SPENDING PATTERNS:
${Object.entries(data.expenses.reduce((acc, exp) => {
  acc[exp.category] = (acc[exp.category] || 0) + exp.amount;
  return acc;
}, {} as Record<string, number>)).map(([cat, amount]) => `- ${cat}: $${amount.toFixed(2)}`).join('\n')}

FINANCIAL GOALS:
${data.savingsGoals.map(goal => `- ${goal.name}: Need $${(goal.targetAmount - goal.currentAmount).toFixed(2)} more`).join('\n')}

Provide budget optimization suggestions in this JSON format:
{
  "adjustments": [
    {
      "category": "Category name",
      "currentAmount": current_budget_amount,
      "suggestedAmount": suggested_new_amount,
      "reasoning": "Why this change is recommended",
      "confidence": 0.8
    }
  ],
  "totalSavings": estimated_monthly_savings,
  "impactAnalysis": "Overall impact description"
}

Focus on realistic, achievable adjustments that align with their spending patterns.
`;
  }

  private buildReportPrompt(data: FinancialData, reportType: string, dateRange: { startDate: string; endDate: string }): string {
    const totalExpenses = data.expenses.reduce((sum, exp) => sum + exp.amount, 0);
    const totalIncome = data.income.reduce((sum, inc) => sum + inc.amount, 0);
    
    return `
Generate a comprehensive financial report for the period ${dateRange.startDate} to ${dateRange.endDate}.

REPORT TYPE: ${reportType}

FINANCIAL SUMMARY:
- Total Income: $${totalIncome.toFixed(2)}
- Total Expenses: $${totalExpenses.toFixed(2)}
- Net Income: $${(totalIncome - totalExpenses).toFixed(2)}

EXPENSE BREAKDOWN:
${Object.entries(data.expenses.reduce((acc, exp) => {
  acc[exp.category] = (acc[exp.category] || 0) + exp.amount;
  return acc;
}, {} as Record<string, number>)).map(([cat, amount]) => `- ${cat}: $${amount.toFixed(2)}`).join('\n')}

SAVINGS GOALS PROGRESS:
${data.savingsGoals.map(goal => `- ${goal.name}: ${((goal.currentAmount/goal.targetAmount)*100).toFixed(1)}% complete`).join('\n')}

Provide a detailed report in this JSON format:
{
  "reportTitle": "Report title",
  "summary": "Executive summary paragraph",
  "sections": [
    {
      "title": "Section title",
      "content": "Section content",
      "data": {}
    }
  ],
  "keyMetrics": [
    {
      "name": "Metric name",
      "value": "Formatted value",
      "trend": "up|down|stable",
      "significance": "What this means"
    }
  ],
  "recommendations": ["Recommendation 1", "Recommendation 2"]
}
`;
  }

  private parseAdviceResponse(response: string): AIAdviceResponse {
    try {
      // Clean the response and extract JSON
      let cleanResponse = response.trim();
      
      // Remove markdown code blocks if present
      cleanResponse = cleanResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '');
      
      // Find JSON object
      const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        
        // Validate structure
        return {
          advice: parsed.advice || 'AI analysis completed successfully.',
          recommendations: Array.isArray(parsed.recommendations) ? parsed.recommendations : [],
          insights: Array.isArray(parsed.insights) ? parsed.insights : []
        };
      }
      
      // Fallback: create structured response from text
      return {
        advice: cleanResponse.substring(0, 300) + (cleanResponse.length > 300 ? '...' : ''),
        recommendations: [{
          category: 'General',
          action: 'Review the AI analysis provided',
          impact: 'Better understanding of your financial situation',
          priority: 'medium' as const
        }],
        insights: [{
          type: 'opportunity' as const,
          message: 'AI analysis completed - review recommendations for improvement opportunities'
        }]
      };
    } catch (error) {
      console.error('Failed to parse AI response:', error);
      return {
        advice: 'AI analysis completed. Please review your financial data for optimization opportunities.',
        recommendations: [],
        insights: []
      };
    }
  }

  private parseBudgetOptimizationResponse(response: string, data: FinancialData): BudgetOptimizationResponse {
    try {
      let cleanResponse = response.trim();
      cleanResponse = cleanResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '');
      
      const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return {
          adjustments: Array.isArray(parsed.adjustments) ? parsed.adjustments : [],
          totalSavings: parsed.totalSavings || 0,
          impactAnalysis: parsed.impactAnalysis || 'Budget optimization analysis completed.'
        };
      }
    } catch (error) {
      console.error('Failed to parse budget optimization response:', error);
    }
    
    return this.getFallbackBudgetOptimization(data);
  }

  private parseReportResponse(response: string, data: FinancialData): ReportResponse {
    try {
      let cleanResponse = response.trim();
      cleanResponse = cleanResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '');
      
      const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return {
          reportTitle: parsed.reportTitle || 'Financial Report',
          summary: parsed.summary || 'Report generated successfully.',
          sections: Array.isArray(parsed.sections) ? parsed.sections : [],
          keyMetrics: Array.isArray(parsed.keyMetrics) ? parsed.keyMetrics : [],
          recommendations: Array.isArray(parsed.recommendations) ? parsed.recommendations : []
        };
      }
    } catch (error) {
      console.error('Failed to parse report response:', error);
    }
    
    return this.getFallbackReport(data, 'monthly_summary');
  }

  private getFallbackAdvice(data: FinancialData): AIAdviceResponse {
    const netIncome = data.monthlyIncome - data.monthlyExpenses;
    const savingsRate = data.monthlyIncome > 0 ? ((netIncome / data.monthlyIncome) * 100) : 0;
    
    const recommendations = [];
    const insights = [];
    
    if (savingsRate < 10) {
      recommendations.push({
        category: 'Savings',
        action: 'Increase your savings rate to at least 10% of income',
        impact: 'Build financial security and emergency fund',
        priority: 'high' as const
      });
      insights.push({
        type: 'warning' as const,
        message: `Your current savings rate of ${savingsRate.toFixed(1)}% is below the recommended 10-20%`
      });
    }
    
    if (savingsRate > 30) {
      insights.push({
        type: 'achievement' as const,
        message: `Excellent! Your savings rate of ${savingsRate.toFixed(1)}% is well above average`
      });
    }
    
    // Check budget overruns
    data.budgets.forEach(budget => {
      const percentage = (budget.spent / budget.amount) * 100;
      if (percentage > 100) {
        recommendations.push({
          category: budget.category,
          action: `Reduce ${budget.category} spending by $${(budget.spent - budget.amount).toFixed(2)}`,
          impact: 'Get back on track with your budget',
          priority: 'high' as const
        });
      }
    });
    
    return {
      advice: `Based on your financial data, you have a ${savingsRate.toFixed(1)}% savings rate. ${savingsRate < 10 ? 'Focus on reducing expenses and increasing savings.' : savingsRate > 20 ? 'Great job maintaining a healthy savings rate!' : 'You\'re on the right track, consider optimizing your budget further.'}`,
      recommendations,
      insights
    };
  }

  private getFallbackBudgetOptimization(data: FinancialData): BudgetOptimizationResponse {
    const adjustments = data.budgets
      .filter(budget => (budget.spent / budget.amount) > 1.1) // Over budget by 10%
      .map(budget => ({
        category: budget.category,
        currentAmount: budget.amount,
        suggestedAmount: Math.ceil(budget.spent * 1.1),
        reasoning: 'Increase budget to accommodate actual spending patterns with 10% buffer',
        confidence: 0.7
      }));
    
    const totalSavings = adjustments.reduce((sum, adj) => sum + (adj.suggestedAmount - adj.currentAmount), 0);
    
    return {
      adjustments,
      totalSavings: Math.abs(totalSavings),
      impactAnalysis: adjustments.length > 0 
        ? 'Adjusting overrun categories will help you maintain realistic budgets and reduce financial stress.'
        : 'Your budget is well-balanced. Consider minor optimizations to increase savings.'
    };
  }

  private getFallbackReport(data: FinancialData, reportType: string): ReportResponse {
    const totalIncome = data.income.reduce((sum, inc) => sum + inc.amount, 0);
    const totalExpenses = data.expenses.reduce((sum, exp) => sum + exp.amount, 0);
    const netIncome = totalIncome - totalExpenses;
    
    return {
      reportTitle: `${reportType.replace('_', ' ').toUpperCase()} Financial Report`,
      summary: `This period you earned $${totalIncome.toFixed(2)} and spent $${totalExpenses.toFixed(2)}, resulting in a net ${netIncome >= 0 ? 'income' : 'loss'} of $${Math.abs(netIncome).toFixed(2)}.`,
      sections: [
        {
          title: 'Income Analysis',
          content: `Your total income for this period was $${totalIncome.toFixed(2)}. This represents your earning capacity during the analyzed timeframe.`
        },
        {
          title: 'Expense Analysis', 
          content: `Your total expenses were $${totalExpenses.toFixed(2)}. Review your spending categories to identify optimization opportunities.`
        }
      ],
      keyMetrics: [
        {
          name: 'Net Income',
          value: `$${netIncome.toFixed(2)}`,
          trend: netIncome >= 0 ? 'up' : 'down',
          significance: netIncome >= 0 ? 'Positive cash flow' : 'Spending exceeds income'
        },
        {
          name: 'Savings Rate',
          value: `${totalIncome > 0 ? ((netIncome / totalIncome) * 100).toFixed(1) : 0}%`,
          trend: 'stable',
          significance: 'Percentage of income saved'
        }
      ],
      recommendations: [
        netIncome < 0 ? 'Focus on reducing expenses to achieve positive cash flow' : 'Consider investing surplus income for long-term growth',
        'Review and optimize your largest expense categories',
        'Set up automatic savings to build your emergency fund'
      ]
    };
  }

  isConfigured(): boolean {
    return this.config !== null;
  }

  getProviderName(): string {
    return this.config?.provider || 'none';
  }
}

export const aiService = new AIService();